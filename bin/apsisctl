#!/usr/bin/env python

import json
import logging
import os
import ora
from   pathlib import Path
import sys

import apsis.cmdline
import apsis.config
import apsis.lib.argparse
import apsis.lib.logging
from   apsis.lib import terminal
from   apsis.service import DEFAULT_PORT
import apsis.service.client
import apsis.service.main
import apsis.sqlite
from   apsis.sqlite import SqliteDB

#-------------------------------------------------------------------------------

apsis.lib.logging.configure()
log = logging.getLogger(__name__)

parser = apsis.lib.argparse.CommandArgumentParser()
addr = apsis.service.client.get_address()
parser.add_argument(
    "--host", metavar="HOST", default=addr.host,
    help=f"connect to HOST [def: {addr.host}]")
parser.add_argument(
    "--port", metavar="PORT", default=addr.port,
    help=f"connect to PORT [def: {addr.port}]")

def get_client(args):
    return apsis.service.client.Client((args.host, args.port))


#-------------------------------------------------------------------------------
# command: archive

def cmd_archive_runs(args):
    db = SqliteDB.open(args.db)
    archive_db = SqliteDB.create(args.archive_db)
    time = ora.Time(args.time)

    apsis.sqlite.archive_runs(db, archive_db, time, delete=args.delete)


cmd = parser.add_command(
    "archive-runs", cmd_archive_runs,
    description="Moves old runs to an archive DB.")
cmd.add_argument(
    "db", metavar="DBPATH",
    help="path to Apsis database")
cmd.add_argument(
    "archive_db", metavar="ARCPATH",
    help="path to archive database")
cmd.add_argument(
    "time", metavar="TIME", type=ora.Time,
    help="archive runs before TIME")
cmd.add_argument(
    "--delete", action="store_true", default=False,
    help="delete archived runs from DBPATH")

#-------------------------------------------------------------------------------
# command: check-db

def cmd_check_db(args):
    db = SqliteDB.open(args.db)

    apsis.sqlite.check(db)


cmd = parser.add_command(
    "check-db", cmd_check_db,
    description="Checks DB for consistency.")
cmd.add_argument(
    "db", metavar="DBPATH",
    help="path to Apsis database")

#-------------------------------------------------------------------------------
# command: check-job

def cmd_check_job(args):
    path = args.path
    job = apsis.jobs.check_job_file(path)
    if job is not None:
        # FIXME: Use something nicer.
        json.dump(apsis.jobs.job_to_jso(job), sys.stdout, indent=2)


cmd = parser.add_command(
    "check-job", cmd_check_job,
    description="Checks a job file.")
cmd.add_argument(
    "path", metavar="PATH",
    help="check the job file PATH")

#-------------------------------------------------------------------------------
# command: create

def cmd_create(args):
    SqliteDB.create(args.state_path)


cmd = parser.add_command(
    "create", cmd_create,
    description="Initializes an Apsis state file.")
cmd.add_argument(
    "state_path", metavar="PATH",
    help="state file")

#-------------------------------------------------------------------------------
# command: migrate

def cmd_migrate(args):
    SqliteDB.migrate(args.state_path)


cmd = parser.add_command(
    "migrate", cmd_migrate,
    description="Migrates an Apsis state file.")
cmd.add_argument(
    "state_path", metavar="PATH",
    help="state file")

#-------------------------------------------------------------------------------
# command: reload_jobs

def cmd_reload_jobs(args):
    result = get_client(args).reload_jobs(dry_run=args.dry_run)

    if not args.quiet:
        def section(name):
            job_ids = result[name]
            if len(job_ids) > 0:
                print(terminal.UND + "Jobs " + name + terminal.RES)
                for job_id in job_ids:
                    print("- " + apsis.cmdline.JOB + job_id + terminal.RES)
                print()
            return len(job_ids)
        
        if section("removed") + section("added") + section("changed") == 0:
            print("no changes")
        elif result["dry_run"]:
            print(terminal.MAG + "Dry run; no changes made." + terminal.RES)


cmd = parser.add_command(
    "reload-jobs", cmd_reload_jobs,
    description="Reloads jobs from the jobs dir.")
cmd.add_argument(
    "--dry-run", action="store_true", default=False,
    help="determine job changes but don't apply them")
cmd.add_argument(
    "--quiet", action="store_true", default=False,
    help="don't print job changes")

#-------------------------------------------------------------------------------
# command: restart

def cmd_restart(args):
    get_client(args).shut_down(restart=True)


cmd = parser.add_command(
    "restart", cmd_restart,
    description="Restarts the Apsis service.")

#-------------------------------------------------------------------------------
# command: serve

def cmd_serve(args):
    cfg = apsis.config.load(args.config)
    for ovr in args.override:
        name, val = ovr.split("=", 1)
        cfg[name] = val

    restart = apsis.service.main.serve(
        cfg, host=args.host, port=args.port, debug=args.debug)

    if restart:
        # Start all over.
        argv = [sys.executable, *sys.argv]
        log.info(f"restarting: {' '.join(argv)}")
        log.info("...")
        os.execv(argv[0], argv)


cmd = parser.add_command(
    "serve", cmd_serve,
    description="Runs the Apsis service.")

cmd.add_argument(
    "--debug", action="store_true", default=False,
    help="run in debug mode")
# FIXME: Host, port collide with global options.
# FIXME: Can't use localhost on OSX, where it resolves to an IPV6 address,
# until we pick up this Sanic fix:
# https://github.com/channelcat/sanic/pull/1053
cmd.add_argument(
    "--host", metavar="HOST", default="127.0.0.1",
    help="server host address")
cmd.add_argument(
    "--port", metavar="PORT", type=int, default=DEFAULT_PORT,
    help=f"server port [def: {DEFAULT_PORT}]")
cmd.add_argument(
    "--config", metavar="CFGFILE", nargs="?", type=Path, default=None,
    help="read config from CFGFILE")
cmd.add_argument(
    "--override", "-o", metavar="NAME=VAL", action="append", default=[],
    help="override config NAME as VAL")


#-------------------------------------------------------------------------------
# command: shut_down

def cmd_shut_down(args):
    get_client(args).shut_down()


cmd = parser.add_command(
    "shut-down", cmd_shut_down,
    description="Shuts down the Apsis service.")

#-------------------------------------------------------------------------------
# command: version

def cmd_version(args):
    version = get_client(args).version()["version"]
    print(f"server address: {addr.host}:{addr.port}")
    print(f"server version: {version}")
    print(f"client version: {apsis.__version__}")


cmd = parser.add_command(
    "version", cmd_version,
    description="Prints the version information.")

#-------------------------------------------------------------------------------

args = parser.parse_args()

try:
    args.cmd(args)
except apsis.service.client.APIError as err:
    apsis.cmdline.print_lines(
        apsis.cmdline.format_api_error(err), file=sys.stderr)
    raise SystemExit(1)
except (KeyboardInterrupt, BrokenPipeError):
    pass

