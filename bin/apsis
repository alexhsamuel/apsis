#!/usr/bin/env python

import argparse
import fixfmt
import fixfmt.table
import json
import logging
from   ora import Time, Daytime, now, get_display_time_zone
import random
import sys

from   apsis.lib.argparse import HelpFormatter
import apsis.lib.itr
from   apsis.runs import Run
import apsis.service.client

log = logging.getLogger(__name__)

#-------------------------------------------------------------------------------

if sys.stdout.isatty():
    SGR = lambda *cc: "\x1b[" + ";".join( str(c) for c in cc ) + "m"
else:
    SGR = lambda *cc: ""

BLD = SGR( 1)
NBL = SGR( 0)
UND = SGR( 4)
NUN = SGR(24)
BLK = SGR(30)
RED = SGR(31)
GRN = SGR(32)
YEL = SGR(33)
BLU = SGR(34)
MAG = SGR(35)
CYN = SGR(36)
WHT = SGR(37)

COLOR = lambda n: SGR(38, 5, n)

STATE_COLOR = {
    "new"       : COLOR( 17),
    "scheduled" : COLOR(243),
    "running"   : COLOR(136),
    "success"   : COLOR( 29),
    "failure"   : COLOR(124),
    "error"     : COLOR(127),
}

STATE_SYMBOL = {
    "new"       : "\u25ef",
    "scheduled" : "\u25f7",
    "running"   : "\u25b6",
    "success"   : "\u2714",
    "failure"   : "\u2716",
    "error"     : "\u2757",
}

RUN = COLOR( 36)
JOB = COLOR( 30)
ARG = COLOR( 60)

#-------------------------------------------------------------------------------

def parse_at_time(string):
    """
    Parses a time for when to run.

    Accepts a full time or a daytime (next occurrence).
    """
    if string == "now":
        return "now"

    try:
        return Time(string)
    except ValueError:
        pass

    try:
        daytime = Daytime(string)
    except ValueError:
        pass
    else:
        # Assume this is today's daytime in the display time zone, unless
        # that has already passed, in which case use tomorrow.
        z = get_display_time_zone()
        date, daytime_now = now() @ z
        return (date if daytime_now < daytime else date + 1, daytime) @ z

    # FIXME: Accept expressions like "1 hour".

    raise ValueError(f"cannot interpret as time: {string}")


def print_lines(lines):
    for line in lines:
        print(line)


def prefix(prefix, lines):
    for line in lines:
        yield prefix + line


def format_jso(jso, indent=0):
    ind = " " * indent
    wid = 12 - indent
    for key, value in jso.items():
        yield f"{ind}{key:{wid}s}: {value}"


def format_state_symbol(state):
    return STATE_COLOR[state] + STATE_SYMBOL[state] + BLK

format_state_symbol.width = 1


def format_program(program, indent=0):
    yield from format_jso(program, indent=indent)


def format_schedule(schedule, indent=0):
    yield from format_jso(schedule, indent=indent)


def format_instance(run):
    return (
        f"{JOB}{run['job_id']}{BLK} "
        + " ".join( f"{k}={ARG}{v}{BLK}" for k, v in run["args"].items() )
    )


def format_job(job):
    # fmt = lambda k, v: f"{k:12s}: {v}"
    # yield fmt("job_id", job["job_id"])
    # yield fmt("url", job["url"])
    # yield fmt("params", ", ".join(job["params"]))
    # yield "program"
    # yield from format_program(job["program"], indent=2)
    # yield "schedules"
    # for schedule in job["schedules"]:
    #     yield from format_schedule(schedule, indent=2)
    yield from _fmt(None, job)


def _fmt(name, val, width=16, indent=-2):
    prefix = " " * indent
    if isinstance(val, dict):
        if name is not None:
            yield prefix + name + ":"
        for name, val in val.items():
            yield from _fmt(name, val, width, indent + 2)
    elif isinstance(val, list):
        if name is not None:
            yield prefix + name + ":"
        for val in val:
            yield from _fmt("-", val, width, indent + 2)
    else:
        if name is None:
            name = ""
        yield prefix + fixfmt.pad(name, width - indent) + ": " + str(val)


def format_run(run):
    b = "✦"

    # Run ID.
    run_id = run["run_id"]
    yield f"{BLD}run {RUN}{run_id}{BLK}{NBL}"

    # The job.
    job = format_instance(run)
    yield f"{b} job {job}"

    # Rerun info.
    if run["rerun"] != run_id:
        yield f"{b} rerun of run {RUN}{run['rerun']}{BLK}"

    # Current state and relevant time.
    fmt_time = lambda n: format_time(run["times"].get(n, "?"))
    state = run["state"]
    if state == "scheduled":
        time = "for " + fmt_time("schedule")
    elif state == "running":
        time = "since " + fmt_time("running")
    else:
        time = "at " + time(state)
    elapsed = run["meta"].get("elapsed")
    if elapsed is not None:
        time += " elapsed " + format_elapsed(elapsed).lstrip()
    yield f"{STATE_COLOR[state]}{STATE_SYMBOL[state]} {state}{BLK} {time}"

    # Message, if any.
    if run["message"] is not None:
        yield f"➔ {WHT}{run['message']}{BLK}"
    
    yield ""


def format_runs(runs, *, reruns=False):
    # FIXME: Does this really make sense?
    def start_time(run):
        return run["times"].get("running", run["times"].get("schedule", ""))

    # FIXME: Support other sorts.
    runs = sorted(runs.values(), key=start_time)
    if reruns:
        runs = sorted(runs, key=lambda r: r["rerun"])

    table = fixfmt.table.RowTable()
    for pos, run in apsis.lib.itr.find_groups(runs, group=lambda r: r["rerun"]):
        row = {
            "run_id"    : RUN + run["run_id"] + BLK,
            "S"         : run["state"],
            "start"     : start_time(run),
            "elapsed"   : run["meta"].get("elapsed"),
            "job_id"    : JOB + run["job_id"] + BLK,
            **run["args"],
        }
        table.append(**row)
        if reruns and pos in "lo":
            table.text("")

    if table.num_rows > 0:
        table.fmts["S"] = format_state_symbol
        table.fmts["start"] = format_time
        table.fmts["elapsed"] = format_elapsed
        yield from table

    else:
        yield f"{RED}No runs.{BLK}"

    if not reruns:
        yield ""


def format_elapsed(secs):
    secs = round(secs)
    if secs < 3600:
        return f"   {secs // 60:2d}:{secs % 60:02d}"
    else:
        return f"{secs // 3600:2d}:{secs // 60 % 60:02d}:{secs % 60:02d}"
    # FIXME: Add formats for longer times.

format_elapsed.width = 8


def format_time(time, time_now=None):
    PAST = COLOR(236)
    if time_now is None:
        time_now = now()

    time = Time(time)
    date, _ = time @ "display"
    date_now, _ = time_now @ "display"
    if date < date_now:
        return PAST + format(time, "%D %C@") + BLK
    elif time < time_now:
        return format(time, "%D @") + PAST + format(time, "%C") + BLK
    else:
        return format(time, "%D %C@")

format_time.width = 19


#-------------------------------------------------------------------------------

logging.basicConfig(
    format  ="%(asctime)s %(name)-24s [%(levelname)-7s] %(message)s",
    datefmt ="%H:%M:%S",
    level   =logging.WARNING,
)

parser = argparse.ArgumentParser(
    usage="%(prog)s [ OPTIONS ] COMMAND ...",
    formatter_class=HelpFormatter,
)
parser.add_argument(
    "--host", metavar="HOST", default="localhost",
    help="connect to HOST [def: localhost]")
parser.add_argument(
    "--port", metavar="PORT", default=apsis.service.DEFAULT_PORT,
    help=f"connect to PORT [def: {apsis.service.DEFAULT_PORT}]")
parser.add_argument(
    "--log-level", metavar="LEVEL", default="WARNING",
    choices={"DEBUG", "INFO", "WARNING", "ERROR", "CRITICAL"},
    help="log at LEVEL [def: WARNING]")
commands = parser.add_subparsers(title="commands")

def add_command(name, fn, description=None):
    cmd = commands.add_parser(
        name, 
        formatter_class =HelpFormatter, 
        description     =description,
    )
    cmd.set_defaults(cmd=fn)
    return cmd


#--- command: adhoc ------------------------------------------------------------

def cmd_adhoc(client, args):
    time = parse_at_time(args.time)
    if args.shell:
        command = " ".join(args.command)
        run = client.schedule_shell_program(time, command)
    else:
        run = client.schedule_program(time, args.command)
    print_lines(format_run(run))


cmd = add_command(
    "adhoc", cmd_adhoc,
    description="Creates and schedules an ad hoc run.")
cmd.add_argument(
    "time", metavar="TIME",
    help="time to run [time, daytime, 'now']")
cmd.add_argument(
    "command", metavar="CMD...", nargs="+",
    help="command to run")
cmd.add_argument(
    "--shell", action="store_true", default=False,
    help="treat CMD as shell code (contactenated)")

#--- command: job --------------------------------------------------------------

def cmd_job(client, args):
    job_id = args.job  # FIXME
    job = client.get_job(job_id)
    print_lines(format_job(job))


cmd = add_command(
    "job", cmd_job,
    description="Displays a job.")
cmd.add_argument(
    "job", metavar="JOB-ID",
    help="display job with JOB-ID")

#--- command: jobs -------------------------------------------------------------

def cmd_jobs(client, args):
    jobs = client.get_jobs()

    table = fixfmt.table.RowTable()
    table.extend(
        {
            "job_id": job["job_id"],
            "params": ", ".join(job["params"]),
        }
        for job in jobs
    )
    table.print()
    print()


cmd = add_command(
    "jobs", cmd_jobs,
    description="Lists all jobs.")

#--- command: output -----------------------------------------------------------

def cmd_output(client, args):
    output = client.get_output(args.run_id)
    sys.stdout.buffer.write(output)


cmd = add_command(
    "output", cmd_output,
    description="Dumps the output of a run.")
cmd.add_argument(
    "run_id", metavar="RUN-ID")

#--- command: rerun ------------------------------------------------------------

def cmd_rerun(client, arg):
    run = client.rerun(arg.run_id)
    if args.json:
        json.dump(run, sys.stdout, indent=2)
    else:
        print_lines(format_run(run))


cmd = add_command(
    "rerun", cmd_rerun,
    description="Reruns a failed (or error) run.")
cmd.add_argument(
    "run_id", metavar="RUN-ID")
cmd.add_argument(
    "--json", action="store_true", default=False,
    help="dump run as JSON")

#--- command: run --------------------------------------------------------------

def cmd_run(client, args):
    for run_id in args.run_id:
        run = client.get_run(run_id)
        if args.json:
            json.dump(run, sys.stdout, indent=2)
        else:
            print_lines(format_run(run))


cmd = add_command(
    "run", cmd_run,
    description="Displays a run.")
cmd.add_argument(
    "run_id", metavar="RUN-ID", nargs="+")
cmd.add_argument(
    "--json", action="store_true", default=False,
    help="dump run as JSON")

#--- command: runs -------------------------------------------------------------

def cmd_runs(client, arg):
    runs = client.get_runs(
        job_id  =args.job,
        reruns  =args.reruns,
        state   =args.state,
        # FIXME: times
    )

    if args.json:
        json.dump(runs, sys.stdout, indent=2)
    elif args.summary:
        for run in runs.values():
            print_lines(format_run(run))
    else:
        print_lines(format_runs(runs, reruns=args.reruns))


cmd = add_command(
    "runs", cmd_runs,
    description="Queries and displays runs.")
cmd.add_argument(
    "--job", "-j", metavar="JOB-ID", default=None,
    help="show only runs of job JOB-ID")
cmd.add_argument(
    "--reruns", action="store_true", default=False,
    help="show RUN-ID and its reruns")
cmd.add_argument(
    "--state", "-s", metavar="STATE", default=None,
    choices=[ r.name for r in Run.STATE ],
    help="show only runs in STATE")
cmd.add_argument(
    "--times", "-t", metavar="TIMESPAN", default=None,
    help="show only runs in TIMESPAN")

grp = cmd.add_mutually_exclusive_group()
grp.add_argument(
    "--summary", action="store_true", default=False,
    help="summarize each run")
grp.add_argument(
    "--json", action="store_true", default=False,
    help="output as JSON")

#--- command: schedule ---------------------------------------------------------

def cmd_schedule(client, args):
    run = client.schedule(args.job_id, dict(args.args), args.time)
    print_lines(format_run(run))


def parse_arg(arg):
    name, value = arg.split("=", 1)
    return name, value


cmd = add_command(
    "schedule", cmd_schedule,
    description="Creates and schedules a run.")
cmd.add_argument(
    "time", metavar="TIME", type=parse_at_time,
    help="time to run [time, daytime, 'now']")
cmd.add_argument(
    "job_id", metavar="JOB-ID",
    help="run an instance of JOB-ID")
cmd.add_argument(
    "args", metavar="NAME=VAL", type=parse_arg, nargs="*",
    help="run JOB-ID with NAME=VAL")

#--- test commands -------------------------------------------------------------

def cmd_test0(client, args):
    time = now()
    past = args.past
    rng = args.fut - past

    for i in range(args.num):
        run = client.schedule("reruntest", {"id": i}, time + past + rng * random.random())
        log.info(f"scheduled: {run['run_id']}")

cmd = add_command("test0", cmd_test0, description="[TEST] Schedule reruntest.")
cmd.add_argument("num", metavar="NUM", type=int, nargs="?", default=1)
cmd.add_argument("fut", metavar="SECS", type=float, nargs="?", default=60)
cmd.add_argument("past", metavar="SECS", type=float, nargs="?", default=0)

#-------------------------------------------------------------------------------

args = parser.parse_args()
logging.getLogger().setLevel(getattr(logging, args.log_level))
client = apsis.service.client.Client(host=args.host, port=args.port)

try:
    args.cmd(client, args)
except (KeyboardInterrupt, BrokenPipeError):
    pass

